# Ch 04 데이터 표현방식의 이해

### 4-1 컴퓨터가 데이터를 표현하는 방식

#### 2진수, 10진수, 16진수

- 컴퓨터는 2진수를 기반으로 데이터를 표현하고 연산 진행
- 2진수 : 두 개의 기호를 이용해 값(데이터) 표현 <br>
  10진수 : 10개의 기호를 이용해 값(데이터) 표현 <br>
  16진수 : 16개의 기호를 이용해 값(데이터) 표현

  ```
   2진수        10진수           16진수
  [ 0 1 ] 2 3 4 5 6 7 8 9 ] A B C D E F ]
  ```

#### 데이터의 표현단위인 비트(Bit)와 바이트(Byte)

- 비트(Bit) : 컴퓨터가 표현하는 데이터의 최소 단위, 2진수 값 하나를 저장할 수 있는 메모리의 크기 <br>
  바이트(Byte) : 1바이트 = 8비트
- 컴퓨터 메모리의 주소값은 1바이트당 하나의 주소가 할당됨

#### 8진수와 16진수를 이용한 데이터 표현

- C 언어에서는 10진수 외에도 8진수와 16진수를 이용해 데이터 표현 가능

  ```.c
  int num1 = 10;     // 특별한 선언이 없으면 10진수로 인식
  int num2 = 0xA;    // 0x로 시작하면 16진수로 인식
  int num3 = 012;    // 0으로 시작하면 8진수로 인식
  ```
- 표현 방식이 달라도 컴퓨터에서는 세 가지 모두 10진수로 인식하여 10진수의 값을 2진수의 형태로 저장함

  ```.c
  #include <stdio.h>

  int main(void)
  {
    int num1 = 0xA7, num2 = 0x43;
    int num3 = 032, num4 = 024;

    printf("0xA7의 10진수 정수 값: %d \n", num1);
    printf("0x43의 10진수 정수 값: %d \n", num2);
    printf("032의 10진수 정수 값: %d \n", num3);
    printf("024의 10진수 정수 값: %d \n", num4);

    printf("%d-%d=%d \n", num1, num2, num1-num2);
    printf("%d+%d=%d \n", num3, num4, num3+num4);

    return 0;
  }
  ```
  실행 결과
  ```
  0xA7의 10진수 정수 값: 167
  0x43의 10진수 정수 값: 67
  032의 10진수 정수 값: 26
  024의 10진수 정수 값: 20

  167-67=100
  26+20=46
  ```

<br>

### 4-2 정수와 실수의 표현방식

#### 정수의 표현방식

- C 언어는 보통 하나의 정수를 4바이트로 표현하지만 편의상 1바이트를 기준으로 공부
- 정수의 가장왼쪽에 있는 비트 = '부호비트(MSB, Most Significant Bit)' <br>
  표현하고자 하는 수가 양수일 때는 0, 음수일 때는 1을 저장하여 부호 표현

  ```.c
  0  0  0  0  0  0  0  1 = +1
  ㄴ 부호(+,-) 표현
  ```
- MSB를 제외한 나머지 비트 = 데이터의 크기를 나타내는데 사용
- 정수의 표현방식은 바이트의 크기와는 관계 없음 <br>
  (바이트의 크기가 크다 = 그만큼 넓은 범위의 정수를 표현할 수 있다)
- 음의 정수 표현 : 2의 보수를 취해 표현 → '2의 보수법'

  ```
  00000101 (정수 +5)
  ↓
  비트별로 1의 보수를 취함
  11111010
  ↓
  보수를 취한 뒤 1을 더함
  1111011 (정수-5)
  ```

#### 실수의 표현방식

- 예시

  ```
  소수점 이상을 표현하는 1바이트
  10000001   00000101
  ㄴ 부호      ㄴ 소수점 이하를 표현하는 1바이트 
  ```
- 실수를 표현하기 위해 정의된 수식

  ```
  ±(1.m)x2^(e-127)
  ```
  - 컴퓨터는 보다 넓은 범위의 데이터를 표현하기 위해 이와 같은 식을 미리 정의해놓고 <br>
    메모리에 할당된 데이터의 일부 비트는 m의 값을 정하고 일부 비트는 e의 값을 정하는데 <br>
    사용하는 방식으로 실수를 표현
- 컴퓨터가 실수를 표현하는 방식에는 오차가 존재함 : <br>
  위의 수식으로는 실수를 정확히 표현할 수 없으나 해당 값에 아주 가까운 근사치를 이용해 실수를 표현 <br>
  → 이러한 오차를 '부동 소수점 오차'라고 함 <br>
  (컴퓨터가 소수점 이하의 수를 표현할 때 부동 소수점 방식을 사용하기 때문)
- 정밀도를 포기하는 대신 표현할 수 있는 값의 범위를 넓힘
- 실수 표현의 오차 확인하기

  ```.c
  #include <stdio.h>

  int main(void)
  {
    int i;
    float num = 0.0;

    for(i=0; i<100; i++)
    num += 0.1;    // 이 연산을 총 100회 진행

    printf("0.1을 100번 더한 결과: %f \n", num);
    return 0;
  }
  ```
  실행 결과
  ```
  0.1을 100번 더한 결과: 10.000002
  ```
  - 이론적으로 오차 없이 모든 실수를 완벽하게 표현할 수 있는 컴퓨터는 존재하지 않음
  - 실수 표현에 있어서 발생하는 오차는 컴퓨터의 기본적인 특성

<br>

### 4-3 비트 연산자

#### 비트 연산자

- 비트 연산자 : 비트 단위로 연산을 진행하는 연산자
- 메모리 공간의 효율성을 높임

| 연산자 | 연산자의 기능 | 결합방향 |
|:-----:|:----------:|:-----:|
| & | 비트 단위로 AND 연산 <br> 예) num1 & num2 | → |
| ㅣ | 비트 단위로 XOR 연산 <br> 예) num1 ㅣ num2 | → |
| ^ | 비트 단위로 XOR 연산 <br> 예) num1 ^ num2 | → |
| ~ | 단향 연산자로서 피연산자의 모든 비트를 반전시킴 <br> 예) ~num; (num은 변화 없고 반전 결과만 반환) | ← |
| << | 피연산자의 비트 열을 왼쪽으로 이동 <br> 예) num << 2; (num은 변화 없고 왼쪽으로 2칸 이동한 결과만 반환) | → |
| >> | 피연산자의 비트 열을 오른쪽으로 이동 <br> 예) num >> 2; (num은 변화 없고 오른쪽으로 2칸 이동한 결과만 반환) | → |
- `<<` 연산자와 `>>` 연산자 = '비트 이동(Shift) 연산자'

#### `&` 연산자 : 비트단위 AND

- 두 개의 비트가 모두 1일 때 1을 반환하는 연산

  ```
  0&0  0을 반환
  0&1  0을 반환
  1&0  0을 반환
  1&1  1을 반환
  ```
- 예제

  ```.c
  #include <stdio.h>

  int main(void)
  {
    int num1 = 15;    // 00000000 00000000 00000000 00001111
    int num2 = 20;    // 00000000 00000000 00000000 00010100
    int num3 = num1 & num2;    // num1과 num2의 비트단위 & 연산
    printf("AND 연산의 결과: %d \n", num3);
    return 0;
  }
  ```
  실행 결과
  ```
  AND 연산의 결과: 4
  // 00000000 00000000 00000000 00000100
  ```

#### `ㅣ` 연산자 : 비트단위 OR

- 두 개의 비트 중 하나라도 1이면 1을 반환하는 연산

  ```
  0 | 0  0을 반환
  0 | 1  1을 반환
  1 | 0  1을 반환
  1 | 1  1을 반환
  ```
- 예제

  ```.c
  #include <stdio.h>

  int main(void)
  {
    int num1 = 15;    // 00000000 00000000 00000000 00001111
    int num2 = 20;    // 00000000 00000000 00000000 00010100
    int num3 = num1 | num2;    // num1과 num2의 비트단위 | 연산
    printf("OR 연산의 결과: %d \n", num3);
    return 0;
  }
  ```
  실행 결과
  ```
  OR 연산의 결과: 31
  // 00000000 00000000 00000000 00011111
  ```

#### `^` 연산자 : 비트단위 XOR

```.c
#include <stdio.h>

int main(void)
{
  int num1 = 15;    // 00000000 00000000 00000000 00001111
  int num2 = 20;    // 00000000 00000000 00000000 00010100
  int num3 = num1 ^ num2;    // num1과 num2의 비트단위 ^ 연산
  printf("XOR 연산의 결과: %d \n", num3);
  return 0;
}
```
실행 결과

```
XOR 연산의 결과: 27
// 00000000 00000000 00000000 00011011
```

#### `~` 연산자 : 비트단위 NOT

- 비트를 0에서 1로, 1에서 0으로 반전시킴 → '보수연산'
  
  ```
  ~0  1을 반환
  ~1  0을 반환
  ```
- 예제

  ```.c
  #include <stdio.h>

  int main(void)
  {
    int num1 = 15;    // 00000000 00000000 00000000 00001111
    int num2 = ~num1;
    printf("NOT 연산의 결과: %d \n", num2);
    return 0;
  }
  ```
  실행 결과

  ```
  NOT 연산의 결과:
  // 
  ```

#### `<<` 연산자 : 비트의 왼쪽 이동(Shift)

- 두 개의 피연산자 요구
- num1 << num2 : num1의 비트 열을 num2칸씩 왼쪽으로 이동시킨 결과를 반환
- 예제

  ```.c
  #include <stdio.h>

  int main(void)
  {
    int num1 = 15;    // 00000000 00000000 00000000 00001111

    int result1 = num1 << 1;
    int result2 = num1 << 2;
    int result3 = num1 <<3;

    printf("1칸 이동 결과: %d \n", result1);
    printf("2칸 이동 결과: %d \n", result2);
    printf("3칸 이동 결과: %d \n", result3);
    return 0;
  }
  ```
  실행 결과

  ```
  1칸 이동 결과: 30
  2칸 이동 결과: 60
  3칸 이동 결과: 120
  ```
- 왼쪽으로 한 칸씩 이동할 때마다 값은 2배로 증가 <br>
  오른쪽으로 한 칸씩 이동할 때마다 값은 반으로 감소

#### `>>` 연산자 : 비트의 오른쪽 이동(Shift)

- num1 >> num2 : num2의 크기만큼 num1의 비트열이 오른쪽으로 이동한 결과를 반환
- `MSB = 0;` : 밀려나는 오른쪽의 비트들은 소멸, 왼쪽의 빈 자리는 0으로 채워짐 <br>
  `MSB = 1;` : CPU에 따라 음의 값을 유지하기 위해 1을 채우거나 음의 값에 관계없이 0을 채우는 경우로 나뉨
- 예제

  ```.c
  #include <stdio.h>

  int main(void)
  {
    int num1 = -16;    // 11111111 11111111 11111111 11110000
    printf("2칸 오른쪽으로 이동한 결과: %d \n", num1 >> 2);
    printf("3칸 오른쪽으로 이동한 결과: %d \n", num1 >> 3);
    return 0;
  }
  ```
  실행 결과
  ```
  2칸 오른쪽으로 이동한 결과: -4
  3칸 오른쪽으로 이동한 결과: -2
  ```


<br>
<br>


```
240108 Ch 4-1 컴퓨터가 데이터를 표현하는 방식 : 공부 및 정리 완료
       Ch 4-2 정수와 실수의 표현방식 : 공부 및 정리 완료
240109 Ch 4-3 비트 연산자 : 공부 및 정리 완료
```
